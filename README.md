Для запуска убедиьест что у вас установлен python и psycopg2
последний вы можете установить при помощи команды
pip install psycopg2
В скрипте поменяйте значения на свои
if __name__ == "__main__":
    dbname = "ps_test"
    user = "postgres"
    password = "r1gdR1rg"
    host = "localhost"
    port = "5432"
После этого запустите скрипт командой:

python ps_test.py

Следуя подсказкам введете количество одновременных потоков и время в секундах 
для вставки данных.
После этого запустится скрипт вставки данных в назначенное время, после чего
вы получите отчёт о статистике проведённой операции в виде:

Затрачено времени в секундах: 600.214334
Использование памяти в %: 58.9
Использование диска в %: 83.0
         293 function calls in 601.216 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000  601.216  601.216 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 <string>:1(__new__)
        2    0.000    0.000    0.000    0.000 __init__.py:1683(cpu_times)
        2    0.000    0.000    0.000    0.000 __init__.py:1724(_cpu_tot_time)
        1    0.000    0.000    0.000    0.000 __init__.py:1743(_cpu_busy_time)
        1    0.000    0.000    0.000    0.000 __init__.py:1759(_cpu_times_deltas)
        1    0.000    0.000    1.001    1.001 __init__.py:1780(cpu_percent)
        1    0.000    0.000    0.000    0.000 __init__.py:1821(calculate)
        1    0.000    0.000    0.000    0.000 __init__.py:1998(virtual_memory)
        1    0.000    0.000    0.000    0.000 __init__.py:2078(disk_usage)
        2    0.000    0.000    0.000    0.000 _common.py:267(usage_percent)
        2    0.000    0.000    0.000    0.000 _common.py:293(wrapper)
        3    0.000    0.000    0.000    0.000 _common.py:585(open_binary)
        3    0.000    0.000    0.000    0.000 _pslinux.py:219(get_procfs_path)
        1    0.000    0.000    0.000    0.000 _pslinux.py:383(virtual_memory)
        2    0.000    0.000    0.000    0.000 _pslinux.py:563(cpu_times)
        2    0.000    0.000    0.000    0.000 _pslinux.py:575(<listcomp>)
        1    0.000    0.000    0.000    0.000 _psposix.py:123(disk_usage)
        3    0.000    0.000    0.000    0.000 _weakrefset.py:38(_remove)
        3    0.000    0.000    0.000    0.000 _weakrefset.py:81(add)
        1    0.000    0.000  601.216  601.216 ps_test.py:115(measure_performance)
        3    0.000    0.000  600.213  200.071 threading.py:1017(_wait_for_tstate_lock)
        6    0.000    0.000    0.000    0.000 threading.py:1095(daemon)
        3    0.000    0.000    0.000    0.000 threading.py:1177(_make_invoke_excepthook)
        6    0.000    0.000    0.000    0.000 threading.py:1306(current_thread)
        3    0.000    0.000    0.000    0.000 threading.py:222(__init__)
        3    0.000    0.000    0.000    0.000 threading.py:246(__enter__)
        3    0.000    0.000    0.000    0.000 threading.py:249(__exit__)
        3    0.000    0.000    0.000    0.000 threading.py:255(_release_save)
        3    0.000    0.000    0.000    0.000 threading.py:258(_acquire_restore)
        3    0.000    0.000    0.000    0.000 threading.py:261(_is_owned)
        3    0.000    0.000    0.000    0.000 threading.py:270(wait)
        3    0.000    0.000    0.000    0.000 threading.py:505(__init__)
        6    0.000    0.000    0.000    0.000 threading.py:513(is_set)
        3    0.000    0.000    0.001    0.000 threading.py:540(wait)
        3    0.000    0.000    0.000    0.000 threading.py:734(_newname)
        3    0.000    0.000    0.000    0.000 threading.py:761(__init__)
        3    0.000    0.000    0.001    0.000 threading.py:834(start)
        3    0.000    0.000    0.000    0.000 threading.py:944(_stop)
        3    0.000    0.000  600.214  200.071 threading.py:979(join)
        5    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x902780}
        6    0.000    0.000    0.000    0.000 {built-in method _thread.allocate_lock}
        6    0.000    0.000    0.000    0.000 {built-in method _thread.get_ident}
        3    0.000    0.000    0.000    0.000 {built-in method _thread.start_new_thread}
        1    0.000    0.000  601.216  601.216 {built-in method builtins.exec}
       25    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}
        2    0.000    0.000    0.000    0.000 {built-in method builtins.len}
       10    0.000    0.000    0.000    0.000 {built-in method builtins.max}

Где вы сможете оценить метрики сервера при выполнение вставки а так же показатели профилирования.

Из предоставленного отчета можно сделать следующие выводы:

    Производительность в секунду: 8996.786138066473: Программа достигла производительности вставки примерно 8996 записей в секунду. Это означает, что база данных обрабатывает примерно 8996 записей в секунду.

    Использование процессора в %: 2.3: Загрузка процессора составила около 2.3%. Это довольно низкое значение, что может означать, что программа не является CPU-интенсивной.

    Использование памяти в %: 58.9: Использование памяти составило около 58.9%. Это умеренное значение, что может указывать на то, что программа использует средние объемы оперативной памяти.

    Использование диска в %: 83.0: Использование диска составило около 83.0%. Это довольно высокое значение, что может указывать на интенсивное использование дискового ввода/вывода при вставке данных в базу.

    Профилирование кода: В отчете профилировщика видно, что большая часть времени программы затрачивается на ожидание завершения потоков в функции threading.py:979(join). Это ожидание завершения работы потоков.

    Малая доля времени на выполнение кода: Функция measure_performance занимает всего 200.071 секунды из общего времени выполнения в 600.214 секунд.

Исходя из этих данных, можно сделать вывод о том, что программа вставляет данные в базу данных с достаточно высокой производительностью, при этом не сильно нагружая процессор и используя умеренное количество памяти. Однако интенсивное использование диска может быть узким местом в работе программы.
